TCP DUMP 
FLAGS
-i elegir interficie que capturar
-c capturamos un numero concreto de paquetes
-A paquetes en formato ASCII
-w elegir un fichero de tipo ".pcap" que guarda los resultados  (tcpdump -w eth0.pcap -i eth0)
-r para analizar el fichero generado .pcap (tcpdump -r eth0.pcap)
-n analizar IPaddr, mantiene las ip en los resultados y no las traduce a nombres
-->AÃ±adimos en protcolo al final(creo que no hace falta que sea el final) para analizar solo los paquetes con 
ese protcolo. 
port XX para monitorizar un puerto especifico.
src IPaddr para monitorizar paquetes de una ip de origen
dst IPaddr para monitorizar paquetes de una ip de destino
-v verbose output
-vv more verbose output

-x : When parsing and printing, in addition to printing the headers of each packet, print the data of each packet.
-X : hen parsing and printing, in addition to printing the headers of each packet, print the data of each packet (minus its link level header) in hex and ASCII. This is very handy for analysing new protocols.
-s 1500: Snarf snaplen bytes of data from each packet rather than the default of 68. This is useful to see lots of information.


PARA TCP
 --> tcpdump -i enp0s3 'tcp[13]=2 && port 22'

tcpdump -nn -l -q -i enp0s3 'tcp[13]=2 && port 22' 2>/dev/null > /root/test.log 

test connections --> nc   
test tcp connections --> nc -z -v ip port

guardar pid del tcpdump

PARA UDP
usual upd ports: 161 162

--> tcpdump -nn -i enp0s3 udp port XX

PARA ICMP 
-->  tcpdump -l -nni enp0s3 'not src 192.168.0.26 && icmp'


TAILS 
TIEMPO --> awk '/./{time=$1} END{print time}' test.log
IP --> awk '/./{ip=$3} END{print ip}' test.log | cut -d '.' -f1,2,3,4
PUERTO --> awk '/./{port=$3} END{print port}' test.log | cut -d '.' -f5
